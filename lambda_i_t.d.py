# def get_multip(num):
#     mul = []
#     for i in num:
#         if i % 2 == 0:
#             mul.append((i, i**2))
#     return mul

# num = [1, 2, 5, 7, 8, 21, 23, 27, 38]
# get_multip(num)

lambda в Python — это просто еще один способ определения функции. 
Вот базовый синтаксис лямбда-функции в Python:
> lambda arguments: expression
Лямбда принимает любое количество аргументов (или ни одного), 
но состоит из одного выражения. Возвращаемое значение — значение, 
которому присвоена функция.
> f = lambda x: x * x
> f(5) = 25
> f(5, 2) = 10
> f = lambda x, y: x * y
> print(lambda x, y: x * y, 5, 2) ---> 10
map() — это встроенная функция Python, принимающая в качестве аргумента функцию 
и последовательность. Она работает так, что применяет переданную функцию 
к каждому элементу.
> L = [1, 2, 3, 4]
> list(map(lambda x: x**2, L)) ---> [1, 4, 9, 16]
ВНИМАНИЕ: в Python3 функция map возвращает ОБЪЕКТ типа(map), а в Python2 — список.
Так, вместо определения функции и передачи ее в map в качестве аргумента,
можно просто использовать лямбда для быстрого определения ее прямо внутри. 
В этом есть смысл, если упомянутая функция больше не будет использоваться в коде.

filter() — это еще одна встроенная функция, которая фильтрует последовательность 
итерируемого объекта.
Другими словами, функция filter отфильтровывает некоторые элементы итерируемого 
объекта (например, списка) на основе какого-то критерия. 
Критерий определяется за счет передачи функции в качестве аргумента. 
Она же применяется к каждому элементу объекта.
Если возвращаемое значение — True, элемент остается. В противном случае — отклоняется. 
Определим, например, простую функцию, которая возвращает
 True для четных чисел и False — для нечетных:
> print(list(filter(lambda x: x % 2 == 0, [1, 3, 2, 5, 20, 21]))) ---> [2, 20]
функция filter возвращает ОБЪЕКТ! <list> превращает объект в список. 

zip() функция в Python создает итератор, который объединяет элементы из нескольких 
источников данных. Эта функция работает со списками, кортежами, множествами и словарями 
для создания списков или кортежей, включающих все эти данные.
Функция zip() принимает итерируемый объект, например, список, кортеж, множество или 
словарь в качестве аргумента. Затем она генерирует список кортежей, которые содержат 
элементы из каждого объекта, переданного в функцию.

> employee_numbers = [2, 9, 18, 28]
> employee_names = ["Дима", "Марина", "Андрей", "Никита"]
> zipped_values = zip(employee_names, employee_numbers)
> zipped_list = list(zipped_values)
> print(zipped_list) ---> [('Дима', 2), ('Марина', 9), ('Андрей', 18), ('Никита', 28)]

!Как сделать «unzip»
В последнем коде были объединены разные типы данных. Но как восстановить их прежнюю 
форму? Если есть список кортежей (упакованных), которые нужно разделить, 
можно использовать специальный оператор функции zip(). 
Это оператор-звездочка (*).
> employees_zipped = [('Дима', 2), ('Марина', 9), ('Андрей', 18), ('Никита', 28)]
> employee_names, employee_numbers = zip(*employees_zipped)
> print(employee_names) ---> ("Дима", "Марина", "Андрей", "Никита")
> print(employee_numbers) ---> (2, 9, 18, 28)

enumerate(lst[]) - Создает кортеж, где ключ - номер по порядку, а значение - каждый элемент списка
> data = list(enumerate(employee_names))
> print(data) ---> [(0, 'Дима'), (1, 'Марина'), (2, 'Андрей'), (3, 'Никита')]

num ="1,2,5,7,8,21,23,27,38".split(',')
print(f'num - {num}')
num = list(map(int,num))
print(f'num = {num}')
#mult = list(filter(lambda i: i % 2 == 0, num))
mult = list(filter(lambda i: not i % 2, num)) тоже самое
print(f'mult = {mult}')
mult = list(map(lambda i: i**2, mult))
mult = list(map(lambda i: (i, i**2), mult))
print(f'{num} -> {mult}')


# mult = [i**2 for i in (map(int,num)) if i % 2 == 0 ]
